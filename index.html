<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚¿ã‚¹ã‚¯ç®¡ç†ï¼ˆéšå±¤æ§‹é€ ãƒ»ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å¯¾å¿œï¼‰</title>
  <style>
    :root {
      --bar-width: 5px;
      --project-margin: 6px;
      --task-padding: 8px;
      --indent-size: 4px;
    }

    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      background: #f7f7f7;
    }

    #app {
      padding: 16px;
      max-width: 800px;
      margin: auto;
    }

    /* â˜…â˜…â˜… å¤‰æ›´ç‚¹: ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã«è¿½å¾“ã•ã›ã‚‹ â˜…â˜…â˜… */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 8px;
      
      /* ã‚¹ãƒ†ã‚£ãƒƒã‚­ãƒ¼ãƒ˜ãƒƒãƒ€ãƒ¼ã«ã™ã‚‹ãŸã‚ã®è¨­å®š */
      position: sticky;
      top: 0;
      background-color: #f7f7f7; /* bodyã®èƒŒæ™¯è‰²ã¨åŒã˜ã«ã—ã¦ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®é€ã‘ã‚’é˜²ã */
      z-index: 500; /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚ˆã‚Šæ‰‹å‰ã€ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚ˆã‚Šå¥¥ã«é…ç½® */
      padding-top: 12px; /* ä¸Šéƒ¨ã®ä½™ç™½ */
      padding-bottom: 12px; /* ä¸‹éƒ¨ã®ä½™ç™½ */
    }

    h1 {
      margin: 0;
      font-size: 1.4em;
    }

    button {
      cursor: pointer;
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
    #addProjectBtn{
      padding: 1px 1px;
    }

    .project, .task {
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      position: relative;
      margin-top: var(--project-margin);
      padding: var(--task-padding);
    }

    .bar {
      width: var(--bar-width);
      height: 100%;
      position: absolute;
      left: 0;
      top: 0;
      border-top-left-radius: 5px;
      border-bottom-left-radius: 5px;
    }

    .task-content {
      margin-left: calc(var(--bar-width) + 8px);
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 1px;
    }

    .task-list {
      margin-left: var(--indent-size);
      padding-left: 2px;
      border-left: 1px dashed #ccc;
      margin-top: 4px;
    }

    .icon-btn, .drag-handle {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      padding: 4px;
    }

    .drag-handle {
      cursor: grab;
    }

    .popup-menu {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      padding: 4px 6px;
      display: none;
      /* â˜…â˜…â˜… å¤‰æ›´ç‚¹: ãƒ˜ãƒƒãƒ€ãƒ¼ã‚ˆã‚Šæ‰‹å‰ã«è¡¨ç¤ºã•ã›ã‚‹ â˜…â˜…â˜… */
      z-index: 1000; 
    }

    .popup-menu button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 16px;
      margin: 0 3px;
      padding: 2px;
      color: #333;
    }

    .completed-title {
      text-decoration: line-through;
      color: #888;
    }

    .project > .task-list,
    .task > .task-list {
      margin-bottom: 4px;
    }
    .task > .task-content > span.leaf-task {
      text-decoration: underline;
    }
    .leaf-task {
      font-weight: bold;
      background-color: #fffceb;
    }
    .completed-task {
      background-color: #f0f0f0;
      color: #888;
    }
    .completed-task .task-content span {
        text-decoration: line-through;
    }


    /* --- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ« --- */
    #timelineView {
      display: none;
      display: flex;
      gap: 16px;
    }
    .timeline-column {
      flex: 1;
      min-width: 0;
      position: relative;
      padding-top: 8px;
    }
    .timeline-column h2 {
        font-size: 1.1em;
        margin-top: 0;
        color: #555;
        border-bottom: 2px solid #eee;
        padding-bottom: 8px;
    }

    .timeline-separator-item {
        display: flex;
        align-items: center;
        height: 22px;
        cursor: grab;
    }
    .timeline-separator-item .separator-line {
        height: 2px;
        background-color: red;
        width: 100%;
    }
    .timeline-separator-item .drag-handle {
        flex-shrink: 0;
        padding-right: 8px;
    }


    .timeline-item {
        display: flex;
        align-items: center;
        gap: 10px;
        background-color: white;
        padding: 10px 15px;
        margin-bottom: 8px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        border-radius: 4px;
        transition: background-color 0.3s;
    }
    .timeline-item.is-done {
        background-color: #f0f0f0;
    }
    .timeline-item.is-done .timeline-item-header {
        text-decoration: line-through;
        color: #888;
    }
    .timeline-item-content {
        flex-grow: 1;
        border-left: 5px solid;
        padding-left: 10px;
    }
    .timeline-item-header {
        font-weight: bold;
        font-size: 1.1em;
        margin-bottom: 4px;
        cursor: pointer;
    }
    .timeline-item-meta {
        font-size: 0.9em;
        color: #555;
    }
    .timeline-item-meta strong {
        color: #333;
    }
    .timeline-item input[type="checkbox"] {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        cursor: default;
    }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
  <div id="app">
    <header>
        <div>
            <h1>ã‚¿ã‚¹ã‚¯ç®¡ç†</h1>
        </div>
        <div>
            <select id="projectFilter">
                <option value="all">ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</option>
            </select>
            <button id="addProjectBtn">ï¼‹</button>
        </div>
        <div>
            <button id="viewToggleBtn">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¡¨ç¤º</button>
        </div>
    </header>

    <main id="projectList"></main>
    <main id="timelineView">
      <div class="timeline-column" id="dated-tasks-column">
        <h2>æœŸé–“ã‚ã‚Š</h2>
        <div id="dated-tasks-list"></div>
      </div>
      <div class="timeline-column" id="undated-tasks-column">
        <h2>æœŸé–“ãªã—</h2>
        <div id="undated-tasks-list"></div>
      </div>
    </main>
  </div>


<script>
let data = JSON.parse(localStorage.getItem("taskData")) || [];
let datedTimelineOrder = JSON.parse(localStorage.getItem("datedTimelineOrder")) || [];
let undatedTimelineOrder = JSON.parse(localStorage.getItem("undatedTimelineOrder")) || [];

const SEPARATOR_DATED_ID = 'separator-dated-item';
const SEPARATOR_UNDATED_ID = 'separator-undated-item';


const projectList = document.getElementById("projectList");
const timelineView = document.getElementById("timelineView");
const datedTasksList = document.getElementById("dated-tasks-list");
const undatedTasksList = document.getElementById("undated-tasks-list");

const addProjectBtn = document.getElementById("addProjectBtn");
const projectFilter = document.getElementById("projectFilter");
const viewToggleBtn = document.getElementById("viewToggleBtn");

let isTimelineView = false;

const colors = ['#FF5722', '#4CAF50', '#2196F3', '#FFC107', '#9C27B0', '#00BCD4', '#FF9800', '#E91E63', '#795548', '#3F51B5'];

// --- IDç®¡ç† ---
const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

function ensureAllNodesHaveId(nodes) {
    nodes.forEach(node => {
        if (!node.id) {
            node.id = generateId();
        }
        if (node.children) {
            ensureAllNodesHaveId(node.children);
        }
    });
}

// --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
projectFilter.addEventListener("change", () => render());

viewToggleBtn.addEventListener("click", () => {
    isTimelineView = !isTimelineView;
    updateView();
});

addProjectBtn.onclick = () => {
  const name = prompt("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå:");
  if (name) {
    const color = colors[Math.floor(Math.random() * colors.length)];
    data.push({ id: generateId(), name, children: [], color });
    rerenderViews();
  }
};

document.addEventListener('click', (e) => {
    if (!e.target.closest('.popup-menu') && !e.target.closest('.timeline-item-header') && !e.target.closest('.task-content span')) {
        closePopupMenus();
    }
});


// --- ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã¨æç”»ç®¡ç† ---
function saveData() {
  localStorage.setItem("taskData", JSON.stringify(data));
}

function rerenderViews() {
    saveData();
    updateView();
}

function updateView() {
    if (isTimelineView) {
        projectList.style.display = "none";
        timelineView.style.display = "flex";
        projectFilter.style.display = "none";
        addProjectBtn.style.display = "none";
        viewToggleBtn.textContent = "ã‚¿ã‚¹ã‚¯ä¸€è¦§è¡¨ç¤º";
        renderTimeline();
    } else {
        projectList.style.display = "block";
        timelineView.style.display = "none";
        projectFilter.style.display = "inline-block";
        addProjectBtn.style.display = "inline-block";
        viewToggleBtn.textContent = "ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¡¨ç¤º";
        render();
    }
}

// --- ãƒ‡ãƒ¼ã‚¿æ¤œç´¢ãƒ»æ“ä½œ ---
function findTaskById(nodes, id) {
    for (const node of nodes) {
        if (node.id === id) return node;
        if (node.children) {
            const found = findTaskById(node.children, id);
            if (found) return found;
        }
    }
    return null;
}

function findAndRemoveTaskById(nodes, id) {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === id) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children) {
            if (findAndRemoveTaskById(nodes[i].children, id)) {
                return true;
            }
        }
    }
    return false;
}


// --- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ ---
function createPopupMenu(taskOrProject, parent, index, type) {
  const menu = document.createElement("div");
  menu.className = "popup-menu";

  const editBtn = document.createElement("button");
  editBtn.textContent = "âœï¸";
  editBtn.title = "ç·¨é›†";
  editBtn.onclick = (e) => {
    e.stopPropagation();
    const newName = prompt((type === "project" ? "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ" : "ã‚¿ã‚¹ã‚¯") + "åã‚’ç·¨é›†:", taskOrProject.name);
    if (newName) {
      taskOrProject.name = newName;
      rerenderViews();
    }
    closePopupMenus();
  };
  menu.appendChild(editBtn);

  if (type === "task") {
    const periodBtn = document.createElement("button");
    periodBtn.textContent = "ğŸ“…";
    periodBtn.title = "æœŸé–“ç·¨é›†";
    periodBtn.onclick = (e) => {
      e.stopPropagation();
      showPeriodEditDialog(taskOrProject);
      closePopupMenus();
    };
    menu.appendChild(periodBtn);
  }

  const commentBtn = document.createElement("button");
  commentBtn.textContent = "ğŸ’¬";
  commentBtn.title = "ã‚³ãƒ¡ãƒ³ãƒˆ";
  commentBtn.onclick = (e) => {
    e.stopPropagation();
    const newComment = prompt("ã‚³ãƒ¡ãƒ³ãƒˆ:", taskOrProject.comment || "");
    if (newComment !== null) {
      taskOrProject.comment = newComment;
      rerenderViews();
    }
    closePopupMenus();
  };
  menu.appendChild(commentBtn);

  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "ğŸ—‘ï¸";
  deleteBtn.title = "å‰Šé™¤";
  deleteBtn.onclick = (e) => {
    e.stopPropagation();
    if (confirm("æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) {
      if (type === "project") {
        data.splice(index, 1);
      } else if (type === "task") {
        findAndRemoveTaskById(data, taskOrProject.id);
      }
      rerenderViews();
    }
    closePopupMenus();
  };
  menu.appendChild(deleteBtn);

  return menu;
}

function closePopupMenus() {
  document.querySelectorAll(".popup-menu").forEach(menu => menu.style.display = "none");
}

function togglePopupMenu(titleElem, menu) {
  if (menu.style.display === "block") {
    menu.style.display = "none";
  } else {
    closePopupMenus();
    const rect = titleElem.getBoundingClientRect();
    menu.style.top = (window.scrollY + rect.bottom + 4) + "px";
    menu.style.left = (window.scrollX + rect.left) + "px";
    menu.style.display = "block";
  }
}

// --- æœŸé–“ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚° ---
function showPeriodEditDialog(task) {
  const modalBg = document.createElement("div");
    modalBg.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.3); display:flex; align-items:center; justify-content:center; z-index:9999;";
  const modal = document.createElement("div");
    modal.style.cssText = "background:white; padding:16px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.2); min-width:280px;";

  modal.innerHTML = `
    <h3>æœŸé–“ã‚’é¸æŠ</h3>
    <label style="display:block; margin-top:8px;">é–‹å§‹æ—¥:</label>
    <input type="date" id="startDateInput" value="${task.startDate || ''}">
    <label style="display:block; margin-top:8px;">çµ‚äº†æ—¥:</label>
    <input type="date" id="endDateInput" value="${task.endDate || ''}">
    <div style="margin-top:12px; text-align:right;">
        <button id="cancelBtn" style="margin-right:8px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="okBtn">OK</button>
    </div>
  `;
  
  modalBg.appendChild(modal);
  document.body.appendChild(modalBg);
  
  modal.querySelector('#cancelBtn').onclick = () => document.body.removeChild(modalBg);
  modal.querySelector('#okBtn').onclick = () => {
    const start = modal.querySelector('#startDateInput').value;
    const end = modal.querySelector('#endDateInput').value;
    if (start && end && start > end) {
      alert("é–‹å§‹æ—¥ã¯çµ‚äº†æ—¥ä»¥å‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
      return;
    }
    task.startDate = start;
    task.endDate = end;
    rerenderViews();
    document.body.removeChild(modalBg);
  };
}

// --- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æç”» ---
function renderTimeline() {
    datedTasksList.innerHTML = "";
    undatedTasksList.innerHTML = "";

    // 1. å…¨ã¦ã®æœªå®Œäº†ãƒªãƒ¼ãƒ•ã‚¿ã‚¹ã‚¯ã‚’åé›†
    const allDatedTasks = [];
    const allUndatedTasks = [];

    function collectTasks(nodes, path) {
        nodes.forEach(node => {
            const isLeafTask = !node.children || node.children.length === 0;
            const isNotDone = !node.done;
            if (isLeafTask && isNotDone) {
                const project = findProjectForNode(data, node.id);
                const taskInfo = { ...node, projectColor: project ? project.color : '#ccc', path: [...path, node.name] };
                if (taskInfo.startDate) {
                    allDatedTasks.push(taskInfo);
                } else {
                    allUndatedTasks.push(taskInfo);
                }
            }
            if (node.children && node.children.length > 0) {
                collectTasks(node.children, [...path, node.name]);
            }
        });
    }

    function findProjectForNode(projects, nodeId) {
        for (const project of projects) {
            if (findTaskById([project], nodeId)) return project;
        }
        return null;
    }
    
    data.forEach(project => collectTasks(project.children, [project.name]));

    // 2. ã€ŒæœŸé–“ã‚ã‚Šã€ã‚¿ã‚¹ã‚¯ã®ä¸¦ã³æ›¿ãˆã¨æç”»
    const datedSeparator = { id: SEPARATOR_DATED_ID, type: 'separator' };
    let listForRendering;

    // ä¿å­˜ã•ã‚ŒãŸä¸¦ã³é †ãŒãªã„å ´åˆï¼ˆåˆå›è¡¨ç¤ºãªã©ï¼‰ã¯ã€å…¨ã¦ã‚’é–‹å§‹æ—¥ã§ã‚½ãƒ¼ãƒˆ
    if (datedTimelineOrder.length === 0) {
        allDatedTasks.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
        listForRendering = [...allDatedTasks, datedSeparator];
    } else {
        // ä¿å­˜ã•ã‚ŒãŸä¸¦ã³é †ãŒã‚ã‚‹å ´åˆ
        // æ—¢å­˜ã‚¿ã‚¹ã‚¯ã‚’ä¿å­˜é †ã«ä¸¦ã¹ã‚‹
        const existingItems = datedTimelineOrder
            .map(id => id === SEPARATOR_DATED_ID ? datedSeparator : allDatedTasks.find(t => t.id === id))
            .filter(Boolean); // å‰Šé™¤ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’é™¤å¤–

        // æ–°è¦ã‚¿ã‚¹ã‚¯ï¼ˆä¿å­˜é †ã«å«ã¾ã‚Œãªã„ã‚¿ã‚¹ã‚¯ï¼‰ã‚’å–å¾—
        const newTasks = allDatedTasks.filter(t => !datedTimelineOrder.includes(t.id));

        listForRendering = [...existingItems];

        // æ–°è¦ã‚¿ã‚¹ã‚¯ã‚’æ—¥ä»˜é †ã«æŒ¿å…¥
        newTasks.forEach(newTask => {
            let inserted = false;
            for (let i = 0; i < listForRendering.length; i++) {
                const currentItem = listForRendering[i];
                // åŒºåˆ‡ã‚Šç·šã‚„æ—¥ä»˜ã®ãªã„ã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚¹ã‚­ãƒƒãƒ—
                if (currentItem.type === 'separator' || !currentItem.startDate) continue;
                
                // æ–°ã‚¿ã‚¹ã‚¯ãŒç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã‚ˆã‚Šå‰ã®æ—¥ä»˜ãªã‚‰ã€ãã®ä½ç½®ã«æŒ¿å…¥
                if (new Date(newTask.startDate) < new Date(currentItem.startDate)) {
                    listForRendering.splice(i, 0, newTask);
                    inserted = true;
                    break;
                }
            }
            // é©åˆ‡ãªæŒ¿å…¥ä½ç½®ãŒãªã‘ã‚Œã°ã€åŒºåˆ‡ã‚Šç·šã®ç›´å‰ã«è¿½åŠ 
            if (!inserted) {
                const separatorIndex = listForRendering.findIndex(t => t.type === 'separator');
                if (separatorIndex !== -1) {
                    listForRendering.splice(separatorIndex, 0, newTask);
                } else {
                    listForRendering.push(newTask); // åŒºåˆ‡ã‚Šç·šãŒãªã„å ´åˆã¯æœ«å°¾
                }
            }
        });
    }
    
    listForRendering.forEach(task => datedTasksList.appendChild(createTimelineItem(task)));

    // 3. ã€ŒæœŸé–“ãªã—ã€ã‚¿ã‚¹ã‚¯ã®ä¸¦ã³æ›¿ãˆã¨æç”»
    allUndatedTasks.push({ id: SEPARATOR_UNDATED_ID, type: 'separator' });
    const sortWithOrder = (tasks, order) => {
        tasks.sort((a, b) => {
            let indexA = order.indexOf(a.id);
            let indexB = order.indexOf(b.id);
            if (indexA === -1) indexA = Infinity;
            if (indexB === -1) indexB = Infinity;
            return indexA - indexB;
        });
    };
    sortWithOrder(allUndatedTasks, undatedTimelineOrder);
    allUndatedTasks.forEach(task => undatedTasksList.appendChild(createTimelineItem(task)));

    // 4. SortableJSã®åˆæœŸåŒ–
    initSortableForTimelineColumns();
}


function createTimelineItem(task) {
    if (task.type === 'separator') {
        const item = document.createElement('div');
        item.className = 'timeline-separator-item';
        item.dataset.taskId = task.id;

        const handle = createIconButton("â†•ï¸");
        handle.classList.add("drag-handle");
        
        const line = document.createElement('div');
        line.className = 'separator-line';

        item.appendChild(handle);
        item.appendChild(line);
        return item;
    }

    const item = document.createElement('div');
    item.className = 'timeline-item';
    item.dataset.taskId = task.id;

    if (task.done) item.classList.add('is-done');

    const dragHandle = createIconButton("â†•ï¸");
    dragHandle.classList.add("drag-handle");
    dragHandle.onclick = (e) => e.stopPropagation();
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = task.done;
    checkbox.dataset.taskId = task.id;
    checkbox.onclick = (e) => e.stopPropagation();
    checkbox.onchange = (e) => {
        const taskId = e.target.dataset.taskId;
        const targetTask = findTaskById(data, taskId);
        if (targetTask) {
            targetTask.done = e.target.checked;
            saveData();
            item.classList.toggle('is-done', e.target.checked);
        }
    };
    const content = document.createElement('div');
    content.className = 'timeline-item-content';
    content.style.borderLeftColor = task.projectColor || '#ccc';
    const header = document.createElement('div');
    header.className = 'timeline-item-header';
    const pathString = task.path.slice(0, -1).join(' > ');
    let headerHTML = task.name;
    if (pathString) {
        headerHTML += ` <span style="font-weight: normal; font-size: 0.8em; color: #666;">(${pathString})</span>`;
    }
    header.innerHTML = headerHTML;
    header.onclick = (e) => e.stopPropagation();
    header.addEventListener('click', (e) => {
        const currentTask = findTaskById(data, task.id);
        if (currentTask) {
            const menu = createPopupMenu(currentTask, null, null, "task");
            document.body.appendChild(menu);
            togglePopupMenu(header, menu);
        }
    });
    const meta = document.createElement('div');
    meta.className = 'timeline-item-meta';
    let periodText = 'æœŸé–“: æœªè¨­å®š';
    if (task.startDate) {
        const formatDate = d => d ? new Date(d).toLocaleDateString() : '?';
        periodText = `<strong>æœŸé–“:</strong> ${formatDate(task.startDate)} ~ ${formatDate(task.endDate)}`;
    }
    meta.innerHTML = periodText;
    content.appendChild(header);
    content.appendChild(meta);
    item.appendChild(dragHandle);
    item.appendChild(checkbox);
    item.appendChild(content);
    return item;
}


// --- éšå±¤ãƒªã‚¹ãƒˆæç”» ---
function render() {
  const selected = projectFilter.value;
  projectList.innerHTML = "";
  projectFilter.innerHTML = '<option value="all">ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</option>';
  data.forEach(p => projectFilter.add(new Option(p.name, p.name)));
  projectFilter.value = selected;

  data.forEach((project, index) => {
    if (selected === "all" || selected === project.name) {
      projectList.appendChild(createProjectElement(project, index, `${index}`));
    }
  });
  initSortable();
}

function createProjectElement(project, index, path) {
  const div = document.createElement("div");
  div.className = "project";
  const bar = document.createElement("div");
  bar.className = "bar";
  bar.style.backgroundColor = project.color || colors[0];
  const content = document.createElement("div");
  content.className = "task-content";
  const dragHandle = createIconButton("â†•ï¸");
  dragHandle.classList.add("drag-handle");
  const title = document.createElement("span");
  title.textContent = project.name;
  const popupMenu = createPopupMenu(project, null, index, "project");
  document.body.appendChild(popupMenu);
  title.addEventListener("click", (e) => {
    e.stopPropagation();
    togglePopupMenu(title, popupMenu);
  });
  const addSubBtn = createIconButton("â•", () => {
    const name = prompt("ã‚¿ã‚¹ã‚¯å:");
    if (name) {
      if (!project.children) project.children = [];
      project.children.push({ id: generateId(), name, children: [], comment: "", done: false });
      rerenderViews();
    }
  });
  const colorBtn = createIconButton("ğŸ¨", () => {
    const newColor = prompt("0ã€œ9ã®è‰²ç•ªå·ã‚’å…¥åŠ›:\n" + colors.map((c, i) => `${i}: ${c}`).join("\n"));
    const idx = parseInt(newColor);
    if (!isNaN(idx) && colors[idx]) {
      project.color = colors[idx];
      rerenderViews();
    }
  });
  content.append(dragHandle, colorBtn, title, addSubBtn);
  div.append(bar, content);
  if (project.children) {
    const ul = document.createElement("div");
    ul.className = "task-list";
    ul.dataset.path = path;
    project.children.forEach((child, childIndex) => {
      ul.appendChild(createTaskElement(child, project, childIndex, project.color, `${path}-${childIndex}`));
    });
    div.appendChild(ul);
  }
  return div;
}

function createTaskElement(task, parent, index, color, path) {
  const div = document.createElement("div");
  div.className = "task";
  if (task.done) div.classList.add("completed-task");
  const isLeaf = !task.children || task.children.length === 0;
  if (isLeaf && !task.done) div.classList.add("leaf-task");
  const bar = document.createElement("div");
  bar.className = "bar";
  bar.style.backgroundColor = color;
  const content = document.createElement("div");
  content.className = "task-content";
  const checkbox = document.createElement("input");
  checkbox.type = "checkbox";
  checkbox.checked = task.done;
  checkbox.onchange = () => {
    task.done = checkbox.checked;
    checkAutoComplete(task, parent);
    rerenderViews();
  };
  const dragHandle = createIconButton("â†•ï¸");
  dragHandle.classList.add("drag-handle");
  const title = document.createElement("span");
  title.textContent = task.name;
  const popupMenu = createPopupMenu(task, parent, index, "task");
  document.body.appendChild(popupMenu);
  title.addEventListener("click", (e) => {
    e.stopPropagation();
    togglePopupMenu(title, popupMenu);
  });
  const periodSpan = document.createElement("span");
  periodSpan.style.cssText = "font-size:12px; color:#666; margin-left:6px;";
  if (task.startDate) {
    const formatDate = d => new Date(d).toLocaleDateString('ja-JP', {month:'numeric', day:'numeric'});
    periodSpan.textContent = `(${formatDate(task.startDate)}~${task.endDate ? formatDate(task.endDate) : ''})`;
  }
  const addSubBtn = createIconButton("â•", () => {
    const name = prompt("ã‚¿ã‚¹ã‚¯å:");
    if (name) {
      if (!task.children) task.children = [];
      task.children.push({ id: generateId(), name, children: [], comment: "", done: false });
      rerenderViews();
    }
  });
  content.append(dragHandle, checkbox, title, periodSpan, addSubBtn);
  div.append(bar, content);
  if (task.children?.length) {
    const ul = document.createElement("div");
    ul.className = "task-list";
    ul.dataset.path = path;
    task.children.forEach((child, childIndex) => {
      ul.appendChild(createTaskElement(child, task, childIndex, color, `${path}-${childIndex}`));
    });
    div.appendChild(ul);
  }
  return div;
}

function checkAutoComplete(task, parent) {
  if (!parent || !parent.children) return;
  const allDone = parent.children.every(t => t.done);
  if(allDone) parent.done = true;
  else parent.done = false;
}

function createIconButton(icon, action) {
  const btn = document.createElement("button");
  btn.className = "icon-btn";
  btn.innerText = icon;
  btn.onclick = action;
  return btn;
}

// --- SortableJS (ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—) ---
function initSortableForTimelineColumns() {
    if (datedTasksList.sortableInstance) {
        datedTasksList.sortableInstance.destroy();
    }
    if (undatedTasksList.sortableInstance) {
        undatedTasksList.sortableInstance.destroy();
    }
    datedTasksList.sortableInstance = Sortable.create(datedTasksList, {
        animation: 150,
        handle: ".drag-handle",
        group: "timelineTasks",
        onEnd: () => {
            const newOrder = Array.from(datedTasksList.querySelectorAll('.timeline-item, .timeline-separator-item'))
                                  .map(item => item.dataset.taskId);
            datedTimelineOrder = newOrder;
            localStorage.setItem("datedTimelineOrder", JSON.stringify(datedTimelineOrder));
        }
    });
    undatedTasksList.sortableInstance = Sortable.create(undatedTasksList, {
        animation: 150,
        handle: ".drag-handle",
        group: "timelineTasks",
        onEnd: () => {
            const newOrder = Array.from(undatedTasksList.querySelectorAll('.timeline-item, .timeline-separator-item'))
                                  .map(item => item.dataset.taskId);
            undatedTimelineOrder = newOrder;
            localStorage.setItem("undatedTimelineOrder", JSON.stringify(undatedTimelineOrder));
        }
    });
}

function initSortable() {
    if (projectList.sortableInstance) {
        projectList.sortableInstance.destroy();
    }
    projectList.sortableInstance = Sortable.create(projectList, {
        animation: 150,
        handle: ".drag-handle",
        onEnd: function (evt) {
            const [movedItem] = data.splice(evt.oldIndex, 1);
            data.splice(evt.newIndex, 0, movedItem);
            rerenderViews();
        }
    });

    function getArrayFromPath(path) {
        if (!path) return data;
        const indices = path.split('-');
        let current = data;
        for (let i = 0; i < indices.length - 1; i++) {
            current = current[parseInt(indices[i])].children;
        }
        return current[parseInt(indices[indices.length - 1])].children;
    }
    
    document.querySelectorAll(".task-list").forEach(list => {
        if(list.sortableInstance) {
            list.sortableInstance.destroy();
        }
        list.sortableInstance = new Sortable(list, {
            group: 'nested',
            animation: 150,
            handle: ".drag-handle",
            onEnd: (evt) => {
                const fromPath = evt.from.dataset.path;
                const toPath = evt.to.dataset.path;
                
                if (fromPath !== toPath) {
                    alert("ç•°ãªã‚‹éšå±¤ã¸ã®ã‚¿ã‚¹ã‚¯ç§»å‹•ã¯ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
                    rerenderViews();
                    return;
                }

                const parentArray = fromPath ? getArrayFromPath(fromPath) : data;
                if(parentArray){
                    const [movedItem] = parentArray.splice(evt.oldIndex, 1);
                    parentArray.splice(evt.newIndex, 0, movedItem);
                    rerenderViews();
                }
            }
        });
    });
}

// --- åˆæœŸåŒ– ---
ensureAllNodesHaveId(data);
updateView();

</script>
</body>
</html>
