<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚¿ã‚¹ã‚¯ç®¡ç†ï¼ˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ä»˜ãï¼‰</title>
  <script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js'></script>
  <style>
    :root {
      --bar-width: 5px;
      --project-margin: 6px;
      --task-padding: 8px;
      --indent-size: 4px;
    }

    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      background: #f7f7f7;
    }

    #app {
      padding: 16px;
      max-width: 960px;
      margin: auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 12px;
      position: sticky;
      top: 0;
      background-color: #f7f7f7;
      z-index: 500;
      padding: 12px 0;
    }
    
    .header-group {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 1.4em;
    }

    button {
      cursor: pointer;
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
    #addProjectBtn{
      padding: 6px;
      font-size: 18px;
      line-height: 1;
    }

    #view-switcher button {
        background-color: #e0e0e0;
        color: #333;
        border: 1px solid #ccc;
    }
    #view-switcher button.active {
        background-color: #4CAF50;
        color: white;
        border-color: #4CAF50;
    }
    #project-filter-pills-container {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
        width: 100%;
        cursor: grab;
    }

    /* â˜…å¤‰æ›´ç‚¹: é¸æŠã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚ˆã‚Šåˆ†ã‹ã‚Šã‚„ã™ã */
    .project-pill {
        padding: 5px 12px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 13px;
        border: 2px solid transparent;
        color: white;
        flex-shrink: 0;
        transition: all 0.2s ease-in-out; /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ»‘ã‚‰ã‹ã« */
        opacity: 0.75; /* éé¸æŠã®ã‚‚ã®ã‚’å°‘ã—è–„ãã™ã‚‹ */
    }
    .project-pill:not(.active):hover {
        opacity: 1;
        transform: translateY(-2px);
    }
    .project-pill.active {
        border-color: #000;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* å½±ã‚’å¼·ã */
        transform: scale(1.1); /* å°‘ã—å¤§ããã—ã¦ç›®ç«‹ãŸã›ã‚‹ */
        opacity: 1; /* é¸æŠã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¯å®Œå…¨ã«ä¸é€æ˜ã« */
    }
    /* â˜…å¤‰æ›´ã“ã“ã¾ã§ */

    #calendar-task-popup-bg {
        position: fixed; top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.4);
        display: flex; align-items: center; justify-content: center;
        z-index: 10000;
    }
    #calendar-task-popup-content {
        background: #f7f7f7; padding: 12px;
        border-radius: 8px; width: 90%; max-width: 500px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .project, .task {
      background-color: white; border-radius: 5px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1); position: relative;
      margin-top: var(--project-margin);
      padding: var(--task-padding) var(--task-padding) 4px var(--task-padding);
    }
    .bar {
      width: var(--bar-width); height: 100%; position: absolute;
      left: 0; top: 0; border-top-left-radius: 5px; border-bottom-left-radius: 5px;
    }
    .task-content {
      margin-left: calc(var(--bar-width) + 8px); display: flex;
      align-items: center; flex-wrap: wrap; gap: 1px;
    }
    .task-comment {
      font-size: 12px; color: #666; margin-left: calc(var(--bar-width) + 8px);
      padding: 4px 0; white-space: pre-wrap; word-break: break-word;
    }
    .task-list {
      margin-left: var(--indent-size); padding-left: 2px;
      border-left: 1px dashed #ccc; margin-top: 4px;
    }
    .icon-btn, .drag-handle {
      background: none; border: none; font-size: 16px;
      cursor: pointer; padding: 4px;
    }
    .drag-handle { cursor: grab; }
    .popup-menu {
      position: absolute; background: white; border: 1px solid #ccc;
      border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      padding: 4px 6px; display: none; 
      z-index: 10001; 
    }
    .popup-menu button {
      background: none; border: none; cursor: pointer;
      font-size: 16px; margin: 0 3px; padding: 2px; color: #333;
    }
    .completed-title { text-decoration: line-through; color: #888; }
    .project > .task-list, .task > .task-list { margin-bottom: 4px; }
    .task > .task-content > span.leaf-task { text-decoration: underline; }
    .leaf-task { font-weight: bold; background-color: #fffceb; }
    .completed-task { background-color: #f0f0f0; color: #888; }
    .completed-task .task-content span { text-decoration: line-through; }

    #timelineView { display: none; display: flex; gap: 16px; }
    .timeline-column { flex: 1; min-width: 0; position: relative; padding-top: 8px; }
    .timeline-column h2 {
      font-size: 1.1em; margin-top: 0; color: #555;
      border-bottom: 2px solid #eee; padding-bottom: 8px;
    }
    .timeline-separator-item { display: flex; align-items: center; height: 22px; cursor: grab; }
    .timeline-separator-item .separator-line { height: 2px; background-color: red; width: 100%; }
    .timeline-separator-item .drag-handle { flex-shrink: 0; padding-right: 8px; }

    .timeline-item {
      display: flex; align-items: center; gap: 10px; background-color: white;
      padding: 10px 15px; margin-bottom: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      border-radius: 4px; transition: background-color 0.3s;
    }
    .timeline-item.is-done { background-color: #f0f0f0; }
    .timeline-item.is-done .timeline-item-header { text-decoration: line-through; color: #888; }
    .timeline-item-content { flex-grow: 1; border-left: 5px solid; padding-left: 10px; }
    .timeline-item-header {
      font-weight: bold; font-size: 1.1em; margin-bottom: 4px; cursor: pointer;
    }
    .timeline-item-meta { font-size: 0.9em; color: #555; }
    .timeline-comment-display {
      margin-top: 4px; font-size: 0.95em; white-space: pre-wrap; word-break: break-word;
    }
    .timeline-item input[type="checkbox"] { width: 20px; height: 20px; flex-shrink: 0; cursor: default; }
    #calendarView { display: none; margin-top: 16px; }
    .fc-event { border: none !important; }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
  <div id="app">
    <header>
        <div class="header-group"><h1>ã‚¿ã‚¹ã‚¯ç®¡ç†</h1>
            <div id="view-switcher">
                <button data-view="list" class="view-btn active">ä¸€è¦§</button>
                <button data-view="timeline" class="view-btn">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³</button>
                <button data-view="calendar" class="view-btn">ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼</button>
            </div>
        </div>
        <div class="header-group"><button id="addProjectBtn">ï¼‹</button></div>
        <div id="project-filter-pills-container"></div>
    </header>

    <main id="projectList"></main>
    <main id="timelineView">
      <div class="timeline-column" id="dated-tasks-column"><h2>æœŸé–“ã‚ã‚Š</h2><div id="dated-tasks-list"></div></div>
      <div class="timeline-column" id="undated-tasks-column"><h2>æœŸé–“ãªã—</h2><div id="undated-tasks-list"></div></div>
    </main>
    <main id="calendarView"></main>
  </div>

<script>
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let data = JSON.parse(localStorage.getItem("taskData")) || [];
let datedTimelineOrder = JSON.parse(localStorage.getItem("datedTimelineOrder")) || [];
let undatedTimelineOrder = JSON.parse(localStorage.getItem("undatedTimelineOrder")) || [];
let currentView = 'list'; let calendarInstance = null; let activeProjectFilter = 'all';

// --- å®šæ•° ---
const SEPARATOR_DATED_ID = 'separator-dated-item'; const SEPARATOR_UNDATED_ID = 'separator-undated-item';
const colors = ['#FF5722', '#4CAF50', '#2196F3', '#FFC107', '#9C27B0', '#00BCD4', '#FF9800', '#E91E63', '#795548', '#3F51B5'];

// --- DOMè¦ç´  ---
const projectList = document.getElementById("projectList"); const timelineView = document.getElementById("timelineView");
const calendarView = document.getElementById("calendarView"); const datedTasksList = document.getElementById("dated-tasks-list");
const undatedTasksList = document.getElementById("undated-tasks-list"); const addProjectBtn = document.getElementById("addProjectBtn");
const viewSwitcher = document.getElementById("view-switcher"); const projectFilterPillsContainer = document.getElementById("project-filter-pills-container");

// --- IDç®¡ç†ã¨åˆæœŸåŒ– ---
const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
function initializeNodes(nodes) {
    nodes.forEach(node => {
        if (!node.id) node.id = generateId();
        if (typeof node.done === 'undefined') node.done = false;
        if (node.children) initializeNodes(node.children);
    });
}

// --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
viewSwitcher.addEventListener("click", (e) => { if (e.target.tagName === 'BUTTON') { currentView = e.target.dataset.view; updateView(); } });
addProjectBtn.onclick = () => {
    const name = prompt("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå:");
    if (name) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        data.push({ id: generateId(), name, children: [], color, done: false });
        rerenderViews();
    }
};
document.addEventListener('click', (e) => {
    if (!e.target.closest('.popup-menu') && !e.target.closest('.timeline-item-header') && !e.target.closest('.task-content span')) closePopupMenus();
    if (e.target.id === 'calendar-task-popup-bg') document.body.removeChild(e.target);
});

// --- ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã¨æç”»ç®¡ç† ---
function saveData() { localStorage.setItem("taskData", JSON.stringify(data)); }
function rerenderViews() { saveData(); updateView(); }
function updateView() {
    projectList.style.display = "none"; timelineView.style.display = "none"; calendarView.style.display = "none";
    viewSwitcher.querySelector('.active')?.classList.remove('active');
    viewSwitcher.querySelector(`[data-view="${currentView}"]`).classList.add('active');
    renderProjectFilterPills();
    initSortableForProjectPills();
    switch (currentView) {
        case 'list': projectList.style.display = "block"; render(); break;
        case 'timeline': timelineView.style.display = "flex"; renderTimeline(); break;
        case 'calendar': calendarView.style.display = "block"; renderCalendar(); break;
    }
}

// --- ãƒ‡ãƒ¼ã‚¿æ¤œç´¢ãƒ»æ“ä½œ ---
function findTaskById(nodes, id) { for (const node of nodes) { if (node.id === id) return node; if (node.children) { const found = findTaskById(node.children, id); if (found) return found; } } return null; }
function findAndRemoveTaskById(nodes, id) { for (let i = 0; i < nodes.length; i++) { if (nodes[i].id === id) { nodes.splice(i, 1); return true; } if (nodes[i].children && findAndRemoveTaskById(nodes[i].children, id)) return true; } return false; }
function findProjectForNode(projects, nodeId) { for (const project of projects) { if (findTaskById([project], nodeId)) return project; } return null; }
function findParent(nodes, childId, parentOfNodes = null) { for (const node of nodes) { if (node.id === childId) return parentOfNodes; if (node.children) { const found = findParent(node.children, childId, node); if (found) return found; } } return null; }
function updateAllAncestorStatus(startNodeId) {
    let parent = findParent(data, startNodeId);
    while(parent) {
        const allChildrenDone = parent.children && parent.children.length > 0 && parent.children.every(child => child.done);
        if (parent.done !== allChildrenDone) {
            parent.done = allChildrenDone;
            parent = findParent(data, parent.id);
        } else {
            break;
        }
    }
}

// --- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ ---
function createPopupMenu(taskOrProject, parent, index, type) {
  const menu = document.createElement("div"); menu.className = "popup-menu";
  const editBtn = document.createElement("button"); editBtn.textContent = "âœï¸"; editBtn.title = "ç·¨é›†";
  editBtn.onclick = (e) => {
    e.stopPropagation(); const newName = prompt((type === "project" ? "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ" : "ã‚¿ã‚¹ã‚¯") + "åã‚’ç·¨é›†:", taskOrProject.name);
    if (newName) { taskOrProject.name = newName; rerenderViews(); } closePopupMenus();
  };
  menu.appendChild(editBtn);
  if (type === 'task') {
      const periodBtn = document.createElement("button"); periodBtn.textContent = "ğŸ“…"; periodBtn.title = "æœŸé–“ç·¨é›†";
      periodBtn.onclick = (e) => { e.stopPropagation(); showPeriodEditDialog(taskOrProject); closePopupMenus(); };
      menu.appendChild(periodBtn);
      const commentBtn = document.createElement("button"); commentBtn.textContent = "ğŸ’¬"; commentBtn.title = "ã‚³ãƒ¡ãƒ³ãƒˆ";
      commentBtn.onclick = (e) => {
        e.stopPropagation(); const newComment = prompt("ã‚³ãƒ¡ãƒ³ãƒˆ:", taskOrProject.comment || "");
        if (newComment !== null) { taskOrProject.comment = newComment; rerenderViews(); } closePopupMenus();
      };
      menu.appendChild(commentBtn);
  }
  const deleteBtn = document.createElement("button"); deleteBtn.textContent = "ğŸ—‘ï¸"; deleteBtn.title = "å‰Šé™¤";
  deleteBtn.onclick = (e) => {
    e.stopPropagation(); if (confirm("æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) {
      if (type === "project") data.splice(index, 1); else if (type === "task") findAndRemoveTaskById(data, taskOrProject.id);
      rerenderViews();
    } closePopupMenus();
  };
  menu.appendChild(deleteBtn); return menu;
}
function closePopupMenus() { document.querySelectorAll(".popup-menu").forEach(menu => menu.style.display = "none"); }
function togglePopupMenu(titleElem, menu) {
  if (menu.style.display === "block") menu.style.display = "none";
  else {
    closePopupMenus();
    const rect = titleElem.getBoundingClientRect();
    menu.style.position = 'fixed'; menu.style.top = (rect.bottom + 4) + "px"; menu.style.left = (rect.left) + "px";
    menu.style.display = "block";
  }
}

// --- æœŸé–“ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚° ---
function showPeriodEditDialog(task) {
  const modalBg = document.createElement("div");
  modalBg.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.3); display:flex; align-items:center; justify-content:center; z-index:10002;";
  const modal = document.createElement("div");
  modal.style.cssText = "background:white; padding:16px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.2); min-width:280px;";
  modal.innerHTML = `<h3>æœŸé–“ã‚’é¸æŠ</h3><label style="display:block; margin-top:8px;">é–‹å§‹æ—¥:</label><input type="date" id="startDateInput" value="${task.startDate || ''}"><label style="display:block; margin-top:8px;">çµ‚äº†æ—¥:</label><input type="date" id="endDateInput" value="${task.endDate || ''}"><div style="margin-top:12px; text-align:right;"><button id="cancelBtn" style="margin-right:8px; background-color: #777;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button><button id="okBtn">OK</button></div>`;
  modalBg.appendChild(modal); document.body.appendChild(modalBg);
  const close = () => document.body.contains(modalBg) && document.body.removeChild(modalBg);
  modalBg.onclick = (e) => { if (e.target === modalBg) close(); };
  modal.querySelector('#cancelBtn').onclick = close;
  modal.querySelector('#okBtn').onclick = () => {
    const start = modal.querySelector('#startDateInput').value, end = modal.querySelector('#endDateInput').value;
    if (start && end && start > end) { alert("é–‹å§‹æ—¥ã¯çµ‚äº†æ—¥ä»¥å‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚"); return; }
    task.startDate = start; task.endDate = end;
    rerenderViews(); close();
  };
}

// --- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ ---
function renderProjectFilterPills() {
    projectFilterPillsContainer.innerHTML = '';
    const allBtn = document.createElement('div'); allBtn.textContent = 'ã™ã¹ã¦';
    allBtn.className = 'project-pill all-projects-pill';
    allBtn.style.backgroundColor = '#6c757d';
    if (activeProjectFilter === 'all') allBtn.classList.add('active');
    allBtn.onclick = () => { activeProjectFilter = 'all'; updateView(); };
    projectFilterPillsContainer.appendChild(allBtn);

    data.forEach(project => {
        const pill = document.createElement('div');
        pill.textContent = project.name.substring(0, 3); pill.title = project.name;
        pill.className = 'project-pill';
        pill.style.backgroundColor = project.color;
        pill.dataset.projectId = project.id;
        if (activeProjectFilter === project.id) pill.classList.add('active');
        pill.onclick = () => { activeProjectFilter = project.id; updateView(); };
        projectFilterPillsContainer.appendChild(pill);
    });
}

// --- ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é–¢é€£æ©Ÿèƒ½ ---
function renderCalendar() {
    const events = [];
    function collectLeafTasks(nodes, project) {
        nodes.forEach(node => {
            const isLeaf = !node.children || node.children.length === 0;
            if (!node.done && isLeaf && node.startDate) {
                if (activeProjectFilter === 'all' || project.id === activeProjectFilter) {
                    events.push({ title: node.name, start: node.startDate, end: node.endDate ? new Date(new Date(node.endDate).getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0] : null, allDay: true, color: project.color, extendedProps: { taskId: node.id } });
                }
            }
            if (node.children) collectLeafTasks(node.children, project);
        });
    }
    data.forEach(project => collectLeafTasks(project.children, project));
    if (calendarInstance) calendarInstance.destroy();
    calendarInstance = new FullCalendar.Calendar(calendarView, {
        locale: 'ja', initialView: 'dayGridMonth', headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,timeGridWeek' },
        events: events,
        eventClick: (info) => {
            info.jsEvent.preventDefault();
            const task = findTaskById(data, info.event.extendedProps.taskId);
            if (task) showCalendarTaskPopup(task);
        }
    });
    calendarInstance.render();
}
function showCalendarTaskPopup(task) {
    const bg = document.createElement('div'); bg.id = 'calendar-task-popup-bg';
    const content = document.createElement('div'); content.id = 'calendar-task-popup-content';
    const timelineItem = createTimelineItem(task, { isDraggable: false });
    content.appendChild(timelineItem);
    bg.appendChild(content); document.body.appendChild(bg);
}

// --- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æç”» ---
function renderTimeline() {
  datedTasksList.innerHTML = ""; undatedTasksList.innerHTML = "";
  const allDatedTasks = [], allUndatedTasks = [];
  function collectTasks(nodes, project) {
    nodes.forEach(node => {
      const isLeafTask = !node.children || node.children.length === 0;
      if (isLeafTask && !node.done) {
        if (activeProjectFilter === 'all' || project.id === activeProjectFilter) {
            const taskInfo = { ...node, projectColor: project?.color || '#ccc' };
            if (taskInfo.startDate) allDatedTasks.push(taskInfo); else allUndatedTasks.push(taskInfo);
        }
      }
      if (node.children?.length) collectTasks(node.children, project);
    });
  }
  data.forEach(p => collectTasks(p.children, p));

  const datedSeparator = { id: SEPARATOR_DATED_ID, type: 'separator' };
  let listForDatedRendering;
  if (datedTimelineOrder.length === 0) { allDatedTasks.sort((a, b) => new Date(a.startDate) - new Date(b.startDate)); listForDatedRendering = [...allDatedTasks, datedSeparator]; }
  else {
      const existingItems = datedTimelineOrder.map(id => id === SEPARATOR_DATED_ID ? datedSeparator : allDatedTasks.find(t => t.id === id)).filter(Boolean);
      const newTasks = allDatedTasks.filter(t => !datedTimelineOrder.includes(t.id)); listForDatedRendering = [...existingItems];
      newTasks.forEach(newTask => {
          let inserted = false;
          for (let i = 0; i < listForDatedRendering.length; i++) {
              const currentItem = listForDatedRendering[i];
              if (currentItem.type === 'separator' || !currentItem.startDate) continue;
              if (new Date(newTask.startDate) < new Date(currentItem.startDate)) { inserted = true; listForDatedRendering.splice(i, 0, newTask); break; }
          }
          if (!inserted) { const sepIdx = listForDatedRendering.findIndex(t => t.type === 'separator'); listForDatedRendering.splice(sepIdx !== -1 ? sepIdx : listForDatedRendering.length, 0, newTask); }
      });
  }
  listForDatedRendering.forEach(task => datedTasksList.appendChild(createTimelineItem(task)));

  allUndatedTasks.push({ id: SEPARATOR_UNDATED_ID, type: 'separator' });
  let listForUndatedRendering;
  if (undatedTimelineOrder.length === 0) listForUndatedRendering = allUndatedTasks;
  else {
      const allUndatedMap = new Map(allUndatedTasks.map(t => [t.id, t]));
      const finalOrdered = undatedTimelineOrder.map(id => allUndatedMap.get(id)).filter(Boolean);
      const newTasks = allUndatedTasks.filter(t => !finalOrdered.some(ot => ot.id === t.id));
      newTasks.forEach(newTask => {
          const originalIndex = allUndatedTasks.findIndex(t => t.id === newTask.id); let insertionIndex = -1;
          for (let i = originalIndex - 1; i >= 0; i--) { const precedingTask = allUndatedTasks[i]; const indexInFinal = finalOrdered.findIndex(t => t.id === precedingTask.id); if (indexInFinal !== -1) { insertionIndex = indexInFinal + 1; break; } }
          if (insertionIndex !== -1) finalOrdered.splice(insertionIndex, 0, newTask);
          else { const sepIdx = finalOrdered.findIndex(t => t.type === 'separator'); finalOrdered.splice(sepIdx !== -1 ? sepIdx : finalOrdered.length, 0, newTask); }
      });
      listForUndatedRendering = finalOrdered;
  }
  listForUndatedRendering.forEach(task => undatedTasksList.appendChild(createTimelineItem(task)));
  initSortableForTimelineColumns();
}

function createTimelineItem(task, options = { isDraggable: true }) {
  if (task.type === 'separator') {
    const item = document.createElement('div'); item.className = 'timeline-separator-item'; item.dataset.taskId = task.id;
    const handle = createIconButton("â†•ï¸"); handle.classList.add("drag-handle");
    const line = document.createElement('div'); line.className = 'separator-line';
    item.append(handle, line); return item;
  }
  const item = document.createElement('div'); item.className = 'timeline-item'; item.dataset.taskId = task.id;
  if (task.done) item.classList.add('is-done');
  const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.checked = task.done;
  checkbox.dataset.taskId = task.id; checkbox.onclick = (e) => e.stopPropagation();
  checkbox.onchange = (e) => {
    const targetTask = findTaskById(data, e.target.dataset.taskId);
    if (targetTask) {
        targetTask.done = e.target.checked;
        updateAllAncestorStatus(targetTask.id);
        saveData();
        item.classList.toggle('is-done', e.target.checked);
    }
  };
  const content = document.createElement('div'); content.className = 'timeline-item-content';
  const project = findProjectForNode(data, task.id); content.style.borderLeftColor = project?.color || '#ccc';
  const header = document.createElement('div'); header.className = 'timeline-item-header';
  const path = findTaskPath(data, task.id); const pathString = path ? path.slice(0, -1).join(' > ') : '';
  const taskNameSpan = document.createElement('span'); taskNameSpan.textContent = task.name;
  header.appendChild(taskNameSpan);
  if (pathString) {
    const pathSpan = document.createElement('span'); pathSpan.style.cssText = "font-weight: normal; font-size: 0.8em; color: #666; margin-left: 8px;";
    pathSpan.textContent = `(${pathString})`; header.appendChild(pathSpan);
  }
  header.addEventListener('click', (e) => {
    e.stopPropagation(); const currentTask = findTaskById(data, task.id);
    if (currentTask) { const menu = createPopupMenu(currentTask, null, null, "task"); document.body.appendChild(menu); togglePopupMenu(header, menu); }
  });
  const meta = document.createElement('div'); meta.className = 'timeline-item-meta';
  let periodText = '';
  if (task.startDate) { const formatDate = d => d ? new Date(d).toLocaleDateString() : '?'; periodText = `${formatDate(task.startDate)} ~ ${formatDate(task.endDate)}`; }
  let commentHTML = '';
  if (task.comment) { const escaped = task.comment.replace(/</g, "&lt;").replace(/>/g, "&gt;"); commentHTML = `<div class="timeline-comment-display">${escaped}</div>`; }
  meta.innerHTML = periodText + commentHTML;
  content.append(header, meta);
  if (options.isDraggable) {
    const dragHandle = createIconButton("â†•ï¸"); dragHandle.classList.add("drag-handle");
    dragHandle.onclick = (e) => e.stopPropagation();
    item.append(dragHandle, checkbox, content);
  } else {
    item.append(checkbox, content);
  }
  return item;
}

function findTaskPath(nodes, taskId, currentPath = []) {
    for (const node of nodes) { const newPath = [...currentPath, node.name]; if (node.id === taskId) return newPath; if (node.children) { const foundPath = findTaskPath(node.children, taskId, newPath); if (foundPath) return foundPath; } }
    return null;
}

// --- éšå±¤ãƒªã‚¹ãƒˆæç”» ---
function render() {
  projectList.innerHTML = "";
  data.forEach((project, index) => { if (activeProjectFilter === "all" || activeProjectFilter === project.id) projectList.appendChild(createProjectElement(project, index)); });
  initSortable();
}
function createProjectElement(project, index) {
  const div = document.createElement("div");
  div.className = "project";
  if (project.done) div.classList.add("completed-task");
  const bar = document.createElement("div"); bar.className = "bar"; bar.style.backgroundColor = project.color || colors[0];
  const content = document.createElement("div"); content.className = "task-content";
  const dragHandle = createIconButton("â†•ï¸"); dragHandle.classList.add("drag-handle");
  const title = document.createElement("span"); title.textContent = project.name;
  const popupMenu = createPopupMenu(project, null, index, "project"); document.body.appendChild(popupMenu);
  title.addEventListener("click", (e) => { e.stopPropagation(); togglePopupMenu(title, popupMenu); });
  const addSubBtn = createIconButton("â•", () => { const name = prompt("ã‚¿ã‚¹ã‚¯å:"); if (name) { if (!project.children) project.children = []; project.children.push({ id: generateId(), name, children: [], comment: "", done: false, startDate: "", endDate: "" }); rerenderViews(); } });
  const colorBtn = createIconButton("ğŸ¨", () => { const newColor = prompt("0ã€œ9ã®è‰²ç•ªå·ã‚’å…¥åŠ›:\n" + colors.map((c, i) => `${i}: ${c}`).join("\n")); const idx = parseInt(newColor); if (!isNaN(idx) && colors[idx]) { project.color = colors[idx]; rerenderViews(); } });
  content.append(dragHandle, colorBtn, title, addSubBtn); div.append(bar, content);
  if (project.children) {
    const ul = document.createElement("div"); ul.className = "task-list";
    project.children.forEach((child, childIndex) => ul.appendChild(createTaskElement(child, project, childIndex, project.color)));
    div.appendChild(ul);
  }
  return div;
}
function createTaskElement(task, parent, index, color) {
  const div = document.createElement("div"); div.className = "task"; if (task.done) div.classList.add("completed-task");
  const isLeaf = !task.children || task.children.length === 0;
  if (isLeaf && !task.done) div.classList.add("leaf-task");
  const bar = document.createElement("div"); bar.className = "bar"; bar.style.backgroundColor = color;
  const content = document.createElement("div"); content.className = "task-content";
  const checkbox = document.createElement("input"); checkbox.type = "checkbox"; checkbox.checked = task.done;
  checkbox.onchange = () => {
    task.done = checkbox.checked;
    updateAllAncestorStatus(task.id);
    rerenderViews();
  };
  const dragHandle = createIconButton("â†•ï¸"); dragHandle.classList.add("drag-handle");
  const title = document.createElement("span"); title.textContent = task.name;
  const popupMenu = createPopupMenu(task, parent, index, "task"); document.body.appendChild(popupMenu);
  title.addEventListener("click", (e) => { e.stopPropagation(); togglePopupMenu(title, popupMenu); });
  const periodSpan = document.createElement("span"); periodSpan.style.cssText = "font-size:12px; color:#666; margin-left:6px;";
  if (task.startDate) { const formatDate = d => new Date(d).toLocaleDateString('ja-JP', {month:'numeric', day:'numeric'}); periodSpan.textContent = `(${formatDate(task.startDate)}~${task.endDate ? formatDate(task.endDate) : ''})`; }
  const addSubBtn = createIconButton("â•", () => { const name = prompt("ã‚¿ã‚¹ã‚¯å:"); if (name) { if (!task.children) task.children = []; task.children.push({ id: generateId(), name, children: [], comment: "", done: false, startDate: task.startDate || "", endDate: task.endDate || "" }); rerenderViews(); } });
  content.append(dragHandle, checkbox, title, periodSpan, addSubBtn); div.append(bar, content);
  if (task.comment) { const commentDiv = document.createElement("div"); commentDiv.className = "task-comment"; commentDiv.textContent = task.comment; div.appendChild(commentDiv); }
  if (task.children?.length) {
    const ul = document.createElement("div"); ul.className = "task-list";
    task.children.forEach((child, childIndex) => ul.appendChild(createTaskElement(child, task, childIndex, color)));
    div.appendChild(ul);
  }
  return div;
}
function createIconButton(icon, action) { const btn = document.createElement("button"); btn.className = "icon-btn"; btn.innerText = icon; if(action) btn.onclick = action; return btn; }

// --- SortableJS (ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—) ---
function initSortableForProjectPills() {
    if (projectFilterPillsContainer.sortableInstance) {
        projectFilterPillsContainer.sortableInstance.destroy();
    }
    projectFilterPillsContainer.sortableInstance = Sortable.create(projectFilterPillsContainer, {
        animation: 150,
        filter: '.all-projects-pill',
        onEnd: function () {
            const newIdOrder = Array.from(projectFilterPillsContainer.querySelectorAll('.project-pill:not(.all-projects-pill)'))
                                    .map(pill => pill.dataset.projectId);
            const reorderedData = newIdOrder.map(id => data.find(p => p.id === id)).filter(Boolean);
            data = reorderedData;
            rerenderViews();
        }
    });
}
function initSortableForTimelineColumns() {
  if (datedTasksList.sortableInstance) datedTasksList.sortableInstance.destroy(); if (undatedTasksList.sortableInstance) undatedTasksList.sortableInstance.destroy();
  datedTasksList.sortableInstance = Sortable.create(datedTasksList, { animation: 150, handle: ".drag-handle", group: "timelineTasks", onEnd: () => { datedTimelineOrder = Array.from(datedTasksList.querySelectorAll('.timeline-item, .timeline-separator-item')).map(item => item.dataset.taskId); localStorage.setItem("datedTimelineOrder", JSON.stringify(datedTimelineOrder)); } });
  undatedTasksList.sortableInstance = Sortable.create(undatedTasksList, { animation: 150, handle: ".drag-handle", group: "timelineTasks", onEnd: () => { undatedTimelineOrder = Array.from(undatedTasksList.querySelectorAll('.timeline-item, .timeline-separator-item')).map(item => item.dataset.taskId); localStorage.setItem("undatedTimelineOrder", JSON.stringify(undatedTimelineOrder)); } });
}
function initSortable() {
  if (projectList.sortableInstance) projectList.sortableInstance.destroy();
  projectList.sortableInstance = Sortable.create(projectList, { animation: 150, handle: ".drag-handle", onEnd: (evt) => { const [movedItem] = data.splice(evt.oldIndex, 1); data.splice(evt.newIndex, 0, movedItem); rerenderViews(); } });
  
  document.querySelectorAll(".task-list").forEach(list => {
    if(list.sortableInstance) list.sortableInstance.destroy();
    list.sortableInstance = new Sortable(list, { group: 'nested', animation: 150, handle: ".drag-handle", onEnd: (evt) => {
        const fromParentEl = evt.from.closest('.project, .task');
        const toParentEl = evt.to.closest('.project, .task');
        if (fromParentEl !== toParentEl) {
             alert("ç•°ãªã‚‹éšå±¤ã¸ã®ã‚¿ã‚¹ã‚¯ç§»å‹•ã¯ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
             rerenderViews();
             return;
        }
        const parentId = fromParentEl.dataset.id;
        const parentNode = parentId ? findTaskById(data, parentId) : null;
        const parentArray = parentNode ? parentNode.children : data;
        
        if (parentArray) {
            const [movedItem] = parentArray.splice(evt.oldIndex, 1);
            parentArray.splice(evt.newIndex, 0, movedItem);
            rerenderViews();
        } else {
            rerenderViews();
        }
      }
    });
  });
}

// --- åˆæœŸåŒ– ---
initializeNodes(data);
updateView();
</script>
</body>
</html>
