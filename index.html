<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚¿ã‚¹ã‚¯ç®¡ç†ï¼ˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ä»˜ãï¼‰</title>
  <script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js'></script>
  <style>
    :root {
      --bar-width: 5px;
      --project-margin: 6px;
      --task-padding: 8px;
      --indent-size: 4px;
    }

    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      background: #f7f7f7;
    }

    #app {
      padding: 16px;
      max-width: 960px;
      margin: auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 12px;
      position: sticky;
      top: 0;
      background-color: #f7f7f7;
      z-index: 500;
      padding: 12px 0;
    }
    
    .header-group {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 1.4em;
    }

    button {
      cursor: pointer;
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
    #addProjectBtn{
      padding: 6px;
      font-size: 18px;
      line-height: 1;
    }

    #view-switcher button {
        background-color: #e0e0e0;
        color: #333;
        border: 1px solid #ccc;
    }
    #view-switcher button.active {
        background-color: #4CAF50;
        color: white;
        border-color: #4CAF50;
    }
    #project-filter-pills-container {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
        width: 100%;
        cursor: grab;
    }

    .project-pill {
        padding: 5px 12px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 13px;
        border: 2px solid transparent;
        color: white;
        flex-shrink: 0;
        transition: all 0.2s ease-in-out;
        opacity: 0.75;
    }
    .project-pill:not(.active):hover {
        opacity: 1;
        transform: translateY(-2px);
    }
    .project-pill.active {
        border-color: #000;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        transform: scale(1.1);
        opacity: 1;
    }
    .project-pill.completed-projects-btn {
        margin-left: auto;
        opacity: 1;
    }

    #calendar-task-popup-bg {
        position: fixed; top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.4);
        display: flex; align-items: center; justify-content: center;
        z-index: 10000;
    }
    #calendar-task-popup-content {
        background: #f7f7f7; padding: 12px;
        border-radius: 8px; width: 90%; max-width: 500px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .project, .task {
      background-color: white; border-radius: 5px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1); position: relative;
      margin-top: var(--project-margin);
      padding: var(--task-padding) var(--task-padding) 4px var(--task-padding);
    }
    .bar {
      width: var(--bar-width); height: 100%; position: absolute;
      left: 0; top: 0; border-top-left-radius: 5px; border-bottom-left-radius: 5px;
    }
    .task-content {
      margin-left: calc(var(--bar-width) + 8px); display: flex;
      align-items: center; flex-wrap: wrap; gap: 1px;
    }
    .task-comment {
      font-size: 12px; color: #666; margin-left: calc(var(--bar-width) + 8px);
      padding: 4px 0; white-space: pre-wrap; word-break: break-word;
    }
    .task-list {
      margin-left: var(--indent-size); padding-left: 2px;
      border-left: 1px dashed #ccc; margin-top: 4px;
    }
    .icon-btn, .drag-handle {
      background: none; border: none; font-size: 16px;
      cursor: pointer; padding: 4px;
    }
    .drag-handle { cursor: grab; }
    .popup-menu {
      position: absolute; background: white; border: 1px solid #ccc;
      border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      padding: 4px 6px; display: none; 
      z-index: 10001; 
    }
    .popup-menu button {
      background: none; border: none; cursor: pointer;
      font-size: 16px; margin: 0 3px; padding: 2px; color: #333;
    }
    .popup-menu .color-picker-container {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        padding: 5px;
        max-width: 130px;
        margin-top: 5px;
        background-color: #f8f9fa;
        border-radius: 4px;
        border-top: 1px solid #eee;
    }
    .popup-menu .color-picker-option {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        box-sizing: border-box;
        transition: transform 0.2s;
    }
    .popup-menu .color-picker-option:hover {
        transform: scale(1.1);
    }
    .popup-menu .color-picker-option.selected {
        border-color: #333;
    }
    .completed-title { text-decoration: line-through; color: #888; }
    .project > .task-list, .task > .task-list { margin-bottom: 4px; }
    .task > .task-content > span.leaf-task { text-decoration: underline; }
    .leaf-task { font-weight: bold; background-color: #fffceb; }
    .completed-task { background-color: #f0f0f0; color: #888; }
    .completed-task .task-content span { text-decoration: line-through; }

    #timelineView { display: none; display: flex; gap: 16px; }
    .timeline-column { flex: 1; min-width: 0; position: relative; padding-top: 8px; }
    .timeline-column h2 {
      font-size: 1.1em; margin-top: 0; color: #555;
      border-bottom: 2px solid #eee; padding-bottom: 8px;
    }
    .timeline-separator-item { display: flex; align-items: center; height: 22px; cursor: grab; }
    .timeline-separator-item .separator-line { height: 2px; background-color: red; width: 100%; }
    .timeline-separator-item .drag-handle { flex-shrink: 0; padding-right: 8px; }

    .timeline-item {
      display: flex; align-items: center; gap: 10px; background-color: white;
      padding: 10px 15px; margin-bottom: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      border-radius: 4px; transition: background-color 0.3s;
    }
    .timeline-item.is-done { background-color: #f0f0f0; }
    .timeline-item.is-done .timeline-item-header { text-decoration: line-through; color: #888; }
    .timeline-item-content { flex-grow: 1; border-left: 5px solid; padding-left: 10px; }
    .timeline-item-header {
      font-weight: bold; font-size: 1.1em; margin-bottom: 4px; cursor: pointer;
    }
    .timeline-item-meta { font-size: 0.9em; color: #555; }
    .timeline-comment-display {
      margin-top: 4px; font-size: 0.95em; white-space: pre-wrap; word-break: break-word;
    }
    .timeline-item input[type="checkbox"] { width: 20px; height: 20px; flex-shrink: 0; cursor: default; }
    #calendarView { display: none; margin-top: 16px; }
    .fc-event { border: none !important; }
    .fc-event.completed-calendar-event {
        background-color: #a9a9a9 !important;
        border-color: #a9a9a9 !important;
        color: white !important;
    }
    .completed-calendar-event .fc-event-title {
        text-decoration: line-through;
    }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
  <div id="app">
    <header>
        <div class="header-group"><h1>ã‚¿ã‚¹ã‚¯ç®¡ç†</h1>
            <div id="view-switcher">
                <button data-view="list" class="view-btn active">ä¸€è¦§</button>
                <button data-view="timeline" class="view-btn">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³</button>
                <button data-view="calendar" class="view-btn">ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼</button>
            </div>
        </div>
        <div class="header-group"><button id="addProjectBtn">ï¼‹</button></div>
        <div id="project-filter-pills-container"></div>
    </header>

    <main id="projectList"></main>
    <main id="timelineView">
      <div class="timeline-column" id="dated-tasks-column"><h2>æœŸé–“ã‚ã‚Š</h2><div id="dated-tasks-list"></div></div>
      <div class="timeline-column" id="undated-tasks-column"><h2>æœŸé–“ãªã—</h2><div id="undated-tasks-list"></div></div>
    </main>
    <main id="calendarView"></main>
  </div>

<script>
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let data = JSON.parse(localStorage.getItem("taskData")) || [];
let datedTimelineOrder = JSON.parse(localStorage.getItem("datedTimelineOrder")) || [];
let undatedTimelineOrder = JSON.parse(localStorage.getItem("undatedTimelineOrder")) || [];
let currentView = 'list'; let calendarInstance = null; let activeProjectFilter = 'all';
let showCompletedProjects = false;

// --- å®šæ•° ---
const SEPARATOR_DATED_ID = 'separator-dated-item'; const SEPARATOR_UNDATED_ID = 'separator-undated-item';
const colors = ['#FF5722', '#4CAF50', '#2196F3', '#FFC107', '#9C27B0', '#00BCD4', '#FF9800', '#E91E63', '#795548', '#3F51B5'];

// --- DOMè¦ç´  ---
const projectList = document.getElementById("projectList"); const timelineView = document.getElementById("timelineView");
const calendarView = document.getElementById("calendarView"); const datedTasksList = document.getElementById("dated-tasks-list");
const undatedTasksList = document.getElementById("undated-tasks-list"); const addProjectBtn = document.getElementById("addProjectBtn");
const viewSwitcher = document.getElementById("view-switcher"); const projectFilterPillsContainer = document.getElementById("project-filter-pills-container");

// --- IDç®¡ç†ã¨åˆæœŸåŒ– ---
const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
function initializeNodes(nodes) {
    nodes.forEach(node => {
        if (!node.id) node.id = generateId();
        if (typeof node.done === 'undefined') node.done = false;
        if (node.children) initializeNodes(node.children);
    });
}

// --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
viewSwitcher.addEventListener("click", (e) => { if (e.target.tagName === 'BUTTON') { currentView = e.target.dataset.view; updateView(); } });
addProjectBtn.onclick = () => {
    const name = prompt("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå:");
    if (name) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        data.push({ id: generateId(), name, children: [], color, done: false });
        rerenderViews();
    }
};
document.addEventListener('click', (e) => {
    if (!e.target.closest('.popup-menu') && !e.target.closest('.timeline-item-header') && !e.target.closest('.task-content span')) closePopupMenus();
    if (e.target.id === 'calendar-task-popup-bg') document.body.removeChild(e.target);
});

// --- ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã¨æç”»ç®¡ç† ---
function saveData() { localStorage.setItem("taskData", JSON.stringify(data)); }
function rerenderViews() { saveData(); updateView(); }
function updateView() {
    projectList.style.display = "none"; timelineView.style.display = "none"; calendarView.style.display = "none";
    viewSwitcher.querySelector('.active')?.classList.remove('active');
    viewSwitcher.querySelector(`[data-view="${currentView}"]`).classList.add('active');
    
    if (currentView !== 'list') {
        showCompletedProjects = false;
    }

    renderProjectFilterPills();
    initSortableForProjectPills();
    switch (currentView) {
        case 'list': projectList.style.display = "block"; render(); break;
        case 'timeline': timelineView.style.display = "flex"; renderTimeline(); break;
        case 'calendar': calendarView.style.display = "block"; renderCalendar(); break;
    }
}

// --- ãƒ‡ãƒ¼ã‚¿æ¤œç´¢ãƒ»æ“ä½œ ---
function findTaskById(nodes, id) { for (const node of nodes) { if (node.id === id) return node; if (node.children) { const found = findTaskById(node.children, id); if (found) return found; } } return null; }
function findAndRemoveTaskById(nodes, id) { for (let i = 0; i < nodes.length; i++) { if (nodes[i].id === id) { nodes.splice(i, 1); return true; } if (nodes[i].children && findAndRemoveTaskById(nodes[i].children, id)) return true; } return false; }
function findProjectForNode(projects, nodeId) { for (const project of projects) { if (findTaskById([project], nodeId)) return project; } return null; }
function findParent(nodes, childId, parentOfNodes = null) { for (const node of nodes) { if (node.id === childId) return parentOfNodes; if (node.children) { const found = findParent(node.children, childId, node); if (found) return found; } } return null; }
function updateAllAncestorStatus(startNodeId) {
    let parent = findParent(data, startNodeId);
    while(parent) {
        const allChildrenDone = parent.children && parent.children.length > 0 && parent.children.every(child => child.done);
        if (parent.done !== allChildrenDone) {
            parent.done = allChildrenDone;
            parent = findParent(data, parent.id);
        } else {
            break;
        }
    }
}

function updateVisualStatusInDOM(startNodeId) {
    let node = findTaskById(data, startNodeId);
    if (!node) return;

    let element = document.querySelector(`[data-id="${startNodeId}"]`);
    if (element) {
        element.classList.toggle('completed-task', node.done);
    }

    let parent = findParent(data, startNodeId);
    while(parent) {
        const parentElement = document.querySelector(`[data-id="${parent.id}"]`);
        if (parentElement) {
            parentElement.classList.toggle('completed-task', parent.done);
        }
        if (!findParent(data, parent.id)) {
            break;
        }
        parent = findParent(data, parent.id);
    }
}

function addTaskAndUpdateDOM(parent, taskName) {
    if (!parent.children) parent.children = [];
    const newTask = { id: generateId(), name: taskName, children: [], comment: "", done: false, startDate: parent.startDate || "", endDate: parent.endDate || "" };
    parent.children.push(newTask);

    const wasParentDone = parent.done;
    if (wasParentDone) {
        parent.done = false;
        updateAllAncestorStatus(parent.id);
    }
    
    saveData();

    const parentEl = document.querySelector(`[data-id="${parent.id}"]`);
    if (!parentEl) { rerenderViews(); return; }

    let taskListEl = parentEl.querySelector('.task-list');
    if (!taskListEl) {
        taskListEl = document.createElement("div");
        taskListEl.className = "task-list";
        parentEl.appendChild(taskListEl);
    }
    
    const project = findProjectForNode(data, parent.id) || parent;
    const colorForTasks = project.color;

    const newTaskEl = createTaskElement(newTask, parent, parent.children.length - 1, colorForTasks);
    taskListEl.appendChild(newTaskEl);
    
    if (!taskListEl.sortableInstance) {
        initSingleSortableList(taskListEl);
    }

    if (wasParentDone) {
        let current = parent;
        while(current) {
            const currentEl = document.querySelector(`[data-id="${current.id}"]`);
            if (currentEl) {
                currentEl.classList.remove('completed-task');
                const bar = currentEl.querySelector('.bar');
                if (bar) {
                    const projectForBar = findProjectForNode(data, current.id) || current;
                    bar.style.backgroundColor = projectForBar.color || colors[0];
                }
            }
            current = findParent(data, current.id);
        }
    }
}


// --- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ ---
function createPopupMenu(taskOrProject, parent, index, type) {
  const menu = document.createElement("div"); menu.className = "popup-menu";
  
  if (type === "project" && taskOrProject.done) {
      const restoreBtn = document.createElement("button");
      restoreBtn.textContent = "â†©ï¸ å…ƒã«æˆ»ã™";
      restoreBtn.title = "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’æœªå®Œäº†ã«æˆ»ã—ã¾ã™";
      restoreBtn.onclick = (e) => {
          e.stopPropagation();
          taskOrProject.done = false;
          rerenderViews();
          closePopupMenus();
      };
      menu.appendChild(restoreBtn);
  }

  const editBtn = document.createElement("button"); editBtn.textContent = "âœï¸"; editBtn.title = "ç·¨é›†";
  editBtn.onclick = (e) => {
    e.stopPropagation(); const newName = prompt((type === "project" ? "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ" : "ã‚¿ã‚¹ã‚¯") + "åã‚’ç·¨é›†:", taskOrProject.name);
    if (newName) { taskOrProject.name = newName; rerenderViews(); } closePopupMenus();
  };
  menu.appendChild(editBtn);

  if (type === "project" && !taskOrProject.done) {
    const colorBtn = document.createElement("button");
    colorBtn.textContent = "ğŸ¨";
    colorBtn.title = "è‰²ã‚’å¤‰æ›´";
    colorBtn.onclick = (e) => {
        e.stopPropagation();
        const existingPicker = menu.querySelector('.color-picker-container');
        if (existingPicker) {
            menu.removeChild(existingPicker);
            return;
        }
        const pickerContainer = document.createElement('div');
        pickerContainer.className = 'color-picker-container';
        colors.forEach(color => {
            const colorOption = document.createElement('div');
            colorOption.className = 'color-picker-option';
            colorOption.style.backgroundColor = color;
            if (color === taskOrProject.color) {
                colorOption.classList.add('selected');
            }
            colorOption.onclick = () => {
                taskOrProject.color = color;
                rerenderViews();
                closePopupMenus();
            };
            pickerContainer.appendChild(colorOption);
        });
        menu.appendChild(pickerContainer);
    };
    menu.appendChild(colorBtn);
  }

  if (type === 'task') {
    const periodBtn = document.createElement("button"); periodBtn.textContent = "ğŸ“…"; periodBtn.title = "æœŸé–“ç·¨é›†";
    periodBtn.onclick = (e) => { e.stopPropagation(); showPeriodEditDialog(taskOrProject); closePopupMenus(); };
    menu.appendChild(periodBtn);
    const commentBtn = document.createElement("button"); commentBtn.textContent = "ğŸ’¬"; commentBtn.title = "ã‚³ãƒ¡ãƒ³ãƒˆ";
    commentBtn.onclick = (e) => {
      e.stopPropagation(); const newComment = prompt("ã‚³ãƒ¡ãƒ³ãƒˆ:", taskOrProject.comment || "");
      if (newComment !== null) { taskOrProject.comment = newComment; rerenderViews(); } closePopupMenus();
    };
    menu.appendChild(commentBtn);
  }

  const deleteBtn = document.createElement("button"); deleteBtn.textContent = "ğŸ—‘ï¸"; deleteBtn.title = "å‰Šé™¤";
  deleteBtn.onclick = (e) => {
    e.stopPropagation(); if (confirm("æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) {
      const originalDataIndex = data.findIndex(item => item.id === taskOrProject.id);
      if (type === "project" && originalDataIndex > -1) {
          data.splice(originalDataIndex, 1);
      } else if (type === "task") {
          findAndRemoveTaskById(data, taskOrProject.id);
      }
      rerenderViews();
    } closePopupMenus();
  };
  menu.appendChild(deleteBtn); return menu;
}
function closePopupMenus() { document.querySelectorAll(".popup-menu").forEach(menu => menu.style.display = "none"); }
function togglePopupMenu(titleElem, menu) {
  if (menu.style.display === "block") menu.style.display = "none";
  else {
    closePopupMenus();
    const rect = titleElem.getBoundingClientRect();
    menu.style.position = 'fixed'; menu.style.top = (rect.bottom + 4) + "px"; menu.style.left = (rect.left) + "px";
    menu.style.display = "block";
  }
}

// --- æœŸé–“ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚° ---
function showPeriodEditDialog(task) {
  const modalBg = document.createElement("div");
  modalBg.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.3); display:flex; align-items:center; justify-content:center; z-index:10002;";
  const modal = document.createElement("div");
  modal.style.cssText = "background:white; padding:16px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.2); min-width:280px;";
  modal.innerHTML = `<h3>æœŸé–“ã‚’é¸æŠ</h3><label style="display:block; margin-top:8px;">é–‹å§‹æ—¥:</label><input type="date" id="startDateInput" value="${task.startDate || ''}"><label style="display:block; margin-top:8px;">çµ‚äº†æ—¥:</label><input type="date" id="endDateInput" value="${task.endDate || ''}"><div style="margin-top:12px; text-align:right;"><button id="cancelBtn" style="margin-right:8px; background-color: #777;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button><button id="okBtn">OK</button></div>`;
  modalBg.appendChild(modal); document.body.appendChild(modalBg);
  const close = () => document.body.contains(modalBg) && document.body.removeChild(modalBg);
  modalBg.onclick = (e) => { if (e.target === modalBg) close(); };
  modal.querySelector('#cancelBtn').onclick = close;
  modal.querySelector('#okBtn').onclick = () => {
    const start = modal.querySelector('#startDateInput').value, end = modal.querySelector('#endDateInput').value;
    if (start && end && start > end) { alert("é–‹å§‹æ—¥ã¯çµ‚äº†æ—¥ä»¥å‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚"); return; }
    task.startDate = start; task.endDate = end;
    rerenderViews(); close();
  };
}

// --- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ ---
function renderProjectFilterPills() {
    projectFilterPillsContainer.innerHTML = '';
    const activeProjects = data.filter(p => !p.done);
    const completedProjects = data.filter(p => p.done);
    
    const projectsForPills = showCompletedProjects ? completedProjects : activeProjects;

    const allBtn = document.createElement('div');
    allBtn.textContent = 'ã™ã¹ã¦';
    allBtn.className = 'project-pill all-projects-pill';
    allBtn.style.backgroundColor = '#6c757d';
    if (activeProjectFilter === 'all') {
        allBtn.classList.add('active');
    }
    allBtn.onclick = () => {
        activeProjectFilter = 'all';
        updateView();
    };
    projectFilterPillsContainer.appendChild(allBtn);

    projectsForPills.forEach(project => {
        const pill = document.createElement('div');
        pill.textContent = project.name.substring(0, 3);
        pill.title = project.name;
        pill.className = 'project-pill';
        pill.dataset.projectId = project.id;
        pill.style.backgroundColor = project.color;
        if (activeProjectFilter === project.id) {
            pill.classList.add('active');
        }
        pill.onclick = () => {
            activeProjectFilter = project.id;
            updateView();
        };
        projectFilterPillsContainer.appendChild(pill);
    });

    if (completedProjects.length > 0) {
        const toggleBtn = document.createElement('div');
        toggleBtn.textContent = showCompletedProjects ? 'é€²è¡Œä¸­ã‚’è¡¨ç¤º' : 'å®Œäº†æ¸ˆã‚’è¡¨ç¤º';
        toggleBtn.title = showCompletedProjects ? 'é€²è¡Œä¸­ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ç¤º' : 'å®Œäº†æ¸ˆã¿ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ç¤º';
        toggleBtn.className = 'project-pill completed-projects-btn';
        toggleBtn.style.backgroundColor = '#6c757d';
        toggleBtn.onclick = () => {
            showCompletedProjects = !showCompletedProjects;
            activeProjectFilter = 'all';
            updateView();
        };
        projectFilterPillsContainer.appendChild(toggleBtn);
    }
}

// --- ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é–¢é€£æ©Ÿèƒ½ ---
// â˜…â˜…â˜… å¤‰æ›´ç®‡æ‰€ â˜…â˜…â˜…
function renderCalendar() {
    if (calendarInstance) {
        calendarInstance.destroy();
    }

    calendarInstance = new FullCalendar.Calendar(calendarView, {
        locale: 'ja',
        initialView: 'dayGridMonth',
        headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,timeGridWeek' },
        editable: true,
        
        // eventsãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«é–¢æ•°ã‚’æŒ‡å®šã—ã€ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ›´æ–°æ™‚ã«å¸¸ã«æœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ã‚ˆã†ã«ä¿®æ­£
        events: function(fetchInfo, successCallback, failureCallback) {
            const eventArray = [];
            const projectsToScan = data; // å…¨ã¦ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å¯¾è±¡

            function collectLeafTasksRecursive(nodes, project) {
                nodes.forEach(node => {
                    const isLeaf = !node.children || node.children.length === 0;
                    if (isLeaf) {
                        if (activeProjectFilter === 'all' || project.id === activeProjectFilter) {
                            if (node.done && node.completedDate) {
                                eventArray.push({
                                    title: node.name,
                                    start: node.completedDate,
                                    allDay: true,
                                    extendedProps: { taskId: node.id },
                                    classNames: ['completed-calendar-event']
                                });
                            } 
                            else if (!node.done && node.startDate) {
                                eventArray.push({
                                    title: node.name,
                                    start: node.startDate,
                                    end: node.endDate ? new Date(new Date(node.endDate).getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0] : null,
                                    allDay: true,
                                    color: project.color,
                                    extendedProps: { taskId: node.id }
                                });
                            }
                        }
                    }
                    if (node.children) {
                        collectLeafTasksRecursive(node.children, project);
                    }
                });
            }

            projectsToScan.forEach(project => {
                collectLeafTasksRecursive(project.children, project);
            });
            
            successCallback(eventArray);
        },

        eventDrop: (info) => {
            const task = findTaskById(data, info.event.extendedProps.taskId);
            if (!task) return;
            const newStartDate = info.event.startStr;
            if (task.done) {
                task.completedDate = newStartDate;
            }
            task.startDate = newStartDate;
            if (info.event.end) {
                const endDate = new Date(info.event.end);
                endDate.setDate(endDate.getDate() - 1);
                task.endDate = endDate.toISOString().split('T')[0];
            } else {
                task.endDate = newStartDate;
            }
            saveData();
            calendarInstance.refetchEvents();
        },

        eventClick: (info) => {
            info.jsEvent.preventDefault();
            const task = findTaskById(data, info.event.extendedProps.taskId);
            if (task) showCalendarTaskPopup(task);
        }
    });

    calendarInstance.render();
}

function showCalendarTaskPopup(task) {
    const bg = document.createElement('div'); bg.id = 'calendar-task-popup-bg';
    const content = document.createElement('div'); content.id = 'calendar-task-popup-content';
    const timelineItem = createTimelineItem(task, { isDraggable: false });
    content.appendChild(timelineItem);
    bg.appendChild(content); document.body.appendChild(bg);
}

// --- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æç”» ---
function renderTimeline() {
  datedTasksList.innerHTML = ""; undatedTasksList.innerHTML = "";
  const allDatedTasks = [], allUndatedTasks = [];
  const activeProjects = data.filter(p => !p.done);
  function collectTasks(nodes, project) {
    nodes.forEach(node => {
      const isLeafTask = !node.children || node.children.length === 0;
      if (isLeafTask && !node.done) {
        if (activeProjectFilter === 'all' || project.id === activeProjectFilter) {
            const taskInfo = { ...node, projectColor: project?.color || '#ccc' };
            if (taskInfo.startDate) allDatedTasks.push(taskInfo); else allUndatedTasks.push(taskInfo);
        }
      }
      if (node.children?.length) collectTasks(node.children, project);
    });
  }
  activeProjects.forEach(p => collectTasks(p.children, p));

  const datedSeparator = { id: SEPARATOR_DATED_ID, type: 'separator' };
  let listForDatedRendering;
  if (datedTimelineOrder.length === 0) { allDatedTasks.sort((a, b) => new Date(a.startDate) - new Date(b.startDate)); listForDatedRendering = [...allDatedTasks, datedSeparator]; }
  else {
      const existingItems = datedTimelineOrder.map(id => id === SEPARATOR_DATED_ID ? datedSeparator : allDatedTasks.find(t => t.id === id)).filter(Boolean);
      const newTasks = allDatedTasks.filter(t => !datedTimelineOrder.includes(t.id)); listForDatedRendering = [...existingItems];
      newTasks.forEach(newTask => {
          let inserted = false;
          for (let i = 0; i < listForDatedRendering.length; i++) {
              const currentItem = listForDatedRendering[i];
              if (currentItem.type === 'separator' || !currentItem.startDate) continue;
              if (new Date(newTask.startDate) < new Date(currentItem.startDate)) { inserted = true; listForDatedRendering.splice(i, 0, newTask); break; }
          }
          if (!inserted) { const sepIdx = listForDatedRendering.findIndex(t => t.type === 'separator'); listForDatedRendering.splice(sepIdx !== -1 ? sepIdx : listForDatedRendering.length, 0, newTask); }
      });
  }
  listForDatedRendering.forEach(task => datedTasksList.appendChild(createTimelineItem(task)));

  allUndatedTasks.push({ id: SEPARATOR_UNDATED_ID, type: 'separator' });
  let listForUndatedRendering;
  if (undatedTimelineOrder.length === 0) listForUndatedRendering = allUndatedTasks;
  else {
      const allUndatedMap = new Map(allUndatedTasks.map(t => [t.id, t]));
      const finalOrdered = undatedTimelineOrder.map(id => allUndatedMap.get(id)).filter(Boolean);
      const newTasks = allUndatedTasks.filter(t => !finalOrdered.some(ot => ot.id === t.id));
      newTasks.forEach(newTask => {
          const originalIndex = allUndatedTasks.findIndex(t => t.id === newTask.id); let insertionIndex = -1;
          for (let i = originalIndex - 1; i >= 0; i--) { const precedingTask = allUndatedTasks[i]; const indexInFinal = finalOrdered.findIndex(t => t.id === precedingTask.id); if (indexInFinal !== -1) { insertionIndex = indexInFinal + 1; break; } }
          if (insertionIndex !== -1) finalOrdered.splice(insertionIndex, 0, newTask);
          else { const sepIdx = finalOrdered.findIndex(t => t.type === 'separator'); finalOrdered.splice(sepIdx !== -1 ? sepIdx : finalOrdered.length, 0, newTask); }
      });
      listForUndatedRendering = finalOrdered;
  }
  listForUndatedRendering.forEach(task => undatedTasksList.appendChild(createTimelineItem(task)));
  initSortableForTimelineColumns();
}

function createTimelineItem(task, options = { isDraggable: true }) {
  if (task.type === 'separator') {
    const item = document.createElement('div'); item.className = 'timeline-separator-item'; item.dataset.taskId = task.id;
    const handle = createIconButton("â†•ï¸"); handle.classList.add("drag-handle");
    const line = document.createElement('div'); line.className = 'separator-line';
    item.append(handle, line); return item;
  }
  const item = document.createElement('div'); item.className = 'timeline-item'; item.dataset.taskId = task.id;
  if (task.done) item.classList.add('is-done');
  const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.checked = task.done;
  checkbox.dataset.taskId = task.id; checkbox.onclick = (e) => e.stopPropagation();
  checkbox.onchange = (e) => {
    const targetTask = findTaskById(data, e.target.dataset.taskId);
    if (targetTask) {
        targetTask.done = e.target.checked;
        if (targetTask.done) {
            targetTask.completedDate = new Date().toISOString().split('T')[0];
        } else {
            targetTask.completedDate = null;
        }
        updateAllAncestorStatus(targetTask.id);
        saveData();
        item.classList.toggle('is-done', e.target.checked);
        
        if (currentView === 'calendar') {
            calendarInstance.refetchEvents();
            const popup = document.getElementById('calendar-task-popup-bg');
            if (popup) {
                document.body.removeChild(popup);
            }
        }
    }
  };
  const content = document.createElement('div'); content.className = 'timeline-item-content';
  const project = findProjectForNode(data, task.id); content.style.borderLeftColor = project?.color || '#ccc';
  const header = document.createElement('div'); header.className = 'timeline-item-header';
  const path = findTaskPath(data, task.id); const pathString = path ? path.slice(0, -1).join(' > ') : '';
  const taskNameSpan = document.createElement('span'); taskNameSpan.textContent = task.name;
  header.appendChild(taskNameSpan);
  if (pathString) {
    const pathSpan = document.createElement('span'); pathSpan.style.cssText = "font-weight: normal; font-size: 0.8em; color: #666; margin-left: 8px;";
    pathSpan.textContent = `(${pathString})`; header.appendChild(pathSpan);
  }
  header.addEventListener('click', (e) => {
    e.stopPropagation(); const currentTask = findTaskById(data, task.id);
    if (currentTask) {
        const parentProject = findProjectForNode(data, currentTask.id);
        const menu = createPopupMenu(currentTask, findParent(data, currentTask.id), parentProject?.children.findIndex(c => c.id === currentTask.id), "task");
        document.body.appendChild(menu);
        togglePopupMenu(header, menu);
    }
  });
  const meta = document.createElement('div'); meta.className = 'timeline-item-meta';
  let periodText = '';
  if (task.startDate) { const formatDate = d => d ? new Date(d).toLocaleDateString() : '?'; periodText = `${formatDate(task.startDate)} ~ ${formatDate(task.endDate)}`; }
  let commentHTML = '';
  if (task.comment) { const escaped = task.comment.replace(/</g, "&lt;").replace(/>/g, "&gt;"); commentHTML = `<div class="timeline-comment-display">${escaped}</div>`; }
  meta.innerHTML = periodText + commentHTML;
  content.append(header, meta);
  if (options.isDraggable) {
    const dragHandle = createIconButton("â†•ï¸"); dragHandle.classList.add("drag-handle");
    dragHandle.onclick = (e) => e.stopPropagation();
    item.append(dragHandle, checkbox, content);
  } else {
    item.append(checkbox, content);
  }
  return item;
}

function findTaskPath(nodes, taskId, currentPath = []) {
    for (const node of nodes) { const newPath = [...currentPath, node.name]; if (node.id === taskId) return newPath; if (node.children) { const foundPath = findTaskPath(node.children, taskId, newPath); if (foundPath) return foundPath; } }
    return null;
}

// --- éšå±¤ãƒªã‚¹ãƒˆæç”» ---
function render() {
  projectList.innerHTML = "";
  const projectsToDisplay = showCompletedProjects
    ? data.filter(p => p.done)
    : data.filter(p => !p.done);

  const filteredProjects = projectsToDisplay.filter(project =>
    activeProjectFilter === "all" || activeProjectFilter === project.id
  );

  filteredProjects.forEach((project) => {
    const originalIndex = data.findIndex(p => p.id === project.id);
    projectList.appendChild(createProjectElement(project, originalIndex));
  });

  initSortable();
}

function createProjectElement(project, index) {
  const div = document.createElement("div");
  div.className = "project";
  div.dataset.id = project.id;
  if (project.done) div.classList.add("completed-task");

  const bar = document.createElement("div"); bar.className = "bar";
  bar.style.backgroundColor = project.color || colors[0];

  const content = document.createElement("div"); content.className = "task-content";
  
  if (!project.done) {
      const dragHandle = createIconButton("â†•ï¸"); dragHandle.classList.add("drag-handle");
      content.appendChild(dragHandle);
  }
  
  const title = document.createElement("span"); title.textContent = project.name;
  const popupMenu = createPopupMenu(project, null, index, "project"); document.body.appendChild(popupMenu);
  title.addEventListener("click", (e) => { e.stopPropagation(); togglePopupMenu(title, popupMenu); });
  content.appendChild(title);

  const addSubBtn = createIconButton("â•", () => {
      const name = prompt("ã‚¿ã‚¹ã‚¯å:");
      if (name) {
          addTaskAndUpdateDOM(project, name);
      }
  });
  content.appendChild(addSubBtn);
  
  div.append(bar, content);
  
  if (project.children) {
    const ul = document.createElement("div"); ul.className = "task-list";
    const colorForTasks = project.color;
    project.children.forEach((child, childIndex) => ul.appendChild(createTaskElement(child, project, childIndex, colorForTasks)));
    div.appendChild(ul);
  }
  return div;
}

function createTaskElement(task, parent, index, color) {
  const div = document.createElement("div"); div.className = "task"; div.dataset.id = task.id;
  if (task.done) div.classList.add("completed-task");
  const isLeaf = !task.children || task.children.length === 0;
  if (isLeaf && !task.done) div.classList.add("leaf-task");
  const bar = document.createElement("div"); bar.className = "bar"; bar.style.backgroundColor = color;
  const content = document.createElement("div"); content.className = "task-content";
  
  const isParentProjectDone = findProjectForNode(data, task.id)?.done || false;
  if (!isParentProjectDone) {
      const dragHandle = createIconButton("â†•ï¸"); dragHandle.classList.add("drag-handle");
      content.appendChild(dragHandle);
  }

  const checkbox = document.createElement("input"); checkbox.type = "checkbox"; checkbox.checked = task.done;
  checkbox.onchange = () => {
    task.done = checkbox.checked;
    if (task.done) {
        task.completedDate = new Date().toISOString().split('T')[0];
    } else {
        task.completedDate = null;
    }
    updateAllAncestorStatus(task.id);
    saveData();
    updateVisualStatusInDOM(task.id);
    if (currentView === 'calendar') {
        calendarInstance.refetchEvents();
    }
  };
  content.appendChild(checkbox);

  const title = document.createElement("span"); title.textContent = task.name;
  const popupMenu = createPopupMenu(task, parent, index, "task"); document.body.appendChild(popupMenu);
  title.addEventListener("click", (e) => { e.stopPropagation(); togglePopupMenu(title, popupMenu); });
  content.appendChild(title);

  const periodSpan = document.createElement("span"); periodSpan.style.cssText = "font-size:12px; color:#666; margin-left:6px;";
  if (task.startDate) { const formatDate = d => new Date(d).toLocaleDateString('ja-JP', {month:'numeric', day:'numeric'}); periodSpan.textContent = `(${formatDate(task.startDate)}~${task.endDate ? formatDate(task.endDate) : ''})`; }
  content.appendChild(periodSpan);

  const addSubBtn = createIconButton("â•", () => {
      const name = prompt("ã‚µãƒ–ã‚¿ã‚¹ã‚¯å:");
      if (name) {
          addTaskAndUpdateDOM(task, name);
      }
  });
  content.appendChild(addSubBtn);

  div.append(bar, content);
  if (task.comment) { const commentDiv = document.createElement("div"); commentDiv.className = "task-comment"; commentDiv.textContent = task.comment; div.appendChild(commentDiv); }
  if (task.children?.length) {
    const ul = document.createElement("div"); ul.className = "task-list";
    task.children.forEach((child, childIndex) => ul.appendChild(createTaskElement(child, task, childIndex, color)));
    div.appendChild(ul);
  }
  return div;
}
function createIconButton(icon, action) { const btn = document.createElement("button"); btn.className = "icon-btn"; btn.innerText = icon; if(action) btn.onclick = action; return btn; }

// --- SortableJS (ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—) ---
function initSortableForProjectPills() {
    if (projectFilterPillsContainer.sortableInstance) {
        projectFilterPillsContainer.sortableInstance.destroy();
    }
    projectFilterPillsContainer.sortableInstance = Sortable.create(projectFilterPillsContainer, {
        animation: 150,
        filter: '.all-projects-pill, .completed-projects-btn',
        onEnd: function () {
            const newIdOrder = Array.from(projectFilterPillsContainer.querySelectorAll('.project-pill:not(.all-projects-pill):not(.completed-projects-btn)'))
                                        .map(pill => pill.dataset.projectId);
            
            const projectsToReorder = showCompletedProjects ? data.filter(p => p.done) : data.filter(p => !p.done);
            const otherProjects = showCompletedProjects ? data.filter(p => !p.done) : data.filter(p => p.done);

            const reorderedProjects = newIdOrder.map(id => projectsToReorder.find(p => p.id === id)).filter(Boolean);
            
            data = showCompletedProjects ? [...otherProjects, ...reorderedProjects] : [...reorderedProjects, ...otherProjects];
            rerenderViews();
        }
    });
}
function initSortableForTimelineColumns() {
  if (datedTasksList.sortableInstance) datedTasksList.sortableInstance.destroy(); if (undatedTasksList.sortableInstance) undatedTasksList.sortableInstance.destroy();
  datedTasksList.sortableInstance = Sortable.create(datedTasksList, { animation: 150, handle: ".drag-handle", group: "timelineTasks", onEnd: () => { datedTimelineOrder = Array.from(datedTasksList.querySelectorAll('.timeline-item, .timeline-separator-item')).map(item => item.dataset.taskId); localStorage.setItem("datedTimelineOrder", JSON.stringify(datedTimelineOrder)); } });
  undatedTasksList.sortableInstance = Sortable.create(undatedTasksList, { animation: 150, handle: ".drag-handle", group: "timelineTasks", onEnd: () => { undatedTimelineOrder = Array.from(undatedTasksList.querySelectorAll('.timeline-item, .timeline-separator-item')).map(item => item.dataset.taskId); localStorage.setItem("undatedTimelineOrder", JSON.stringify(undatedTimelineOrder)); } });
}

function initSingleSortableList(list) {
    if(list.sortableInstance) list.sortableInstance.destroy();
    list.sortableInstance = new Sortable(list, {
        group: 'nested', animation: 150, handle: ".drag-handle",
        disabled: showCompletedProjects,
        onEnd: (evt) => {
            const fromParentEl = evt.from.closest('.project, .task');
            const toParentEl = evt.to.closest('.project, .task');
            const fromParentId = fromParentEl.dataset.id;
            const toParentId = toParentEl.dataset.id;
            
            const fromParentNode = fromParentId ? findTaskById(data, fromParentId) : { children: data };
            const [movedItem] = fromParentNode.children.splice(evt.oldIndex, 1);

            const toParentNode = toParentId ? findTaskById(data, toParentId) : { children: data };
            if (!toParentNode.children) toParentNode.children = [];
            toParentNode.children.splice(evt.newIndex, 0, movedItem);
            
            updateAllAncestorStatus(movedItem.id);
            if (fromParentId !== toParentId) {
                if(fromParentNode.id) updateAllAncestorStatus(fromParentNode.id);
            }
            rerenderViews();
        }
    });
}

function initSortable() {
    if (projectList.sortableInstance) projectList.sortableInstance.destroy();
    projectList.sortableInstance = Sortable.create(projectList, {
        animation: 150, handle: ".drag-handle",
        disabled: showCompletedProjects,
        onEnd: (evt) => {
            const projectsToMove = showCompletedProjects ? data.filter(p => p.done) : data.filter(p => !p.done);
            const otherProjects = showCompletedProjects ? data.filter(p => !p.done) : data.filter(p => p.done);
    
            const [movedItem] = projectsToMove.splice(evt.oldIndex, 1);
            projectsToMove.splice(evt.newIndex, 0, movedItem);

            data = showCompletedProjects ? [...otherProjects, ...projectsToMove] : [...projectsToMove, ...otherProjects];
            rerenderViews();
        }
    });
    
    document.querySelectorAll(".task-list").forEach(list => {
        initSingleSortableList(list);
    });
}

// --- åˆæœŸåŒ– ---
initializeNodes(data);
updateView();
</script>
</body>
</html>
